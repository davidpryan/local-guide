<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Guide - Find Nearest Locations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .container {
            max-width: 800px;
            width: 100%;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .locations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .location-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .location-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }

        .location-card.empty {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            cursor: default;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            font-style: italic;
        }

        .location-card.empty:hover {
            transform: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .location-name {
            font-size: 1.3em;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .location-distance {
            font-size: 1.1em;
            color: #667eea;
            font-weight: 500;
            margin-bottom: 5px;
        }

        .location-direction {
            font-size: 0.95em;
            color: #666;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .compass {
            position: relative;
            width: 50px;
            height: 50px;
            border: 2px solid #667eea;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .compass::before {
            content: 'N';
            position: absolute;
            top: 2px;
            font-size: 10px;
            font-weight: bold;
            color: #667eea;
        }

        .compass-arrow {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 20px solid #f44336;
            position: absolute;
            transform-origin: center 65%;
            transition: transform 0.3s ease;
        }

        .compass-arrow::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 10px solid #ccc;
            top: 20px;
            left: -6px;
        }

        .upload-section {
            text-align: center;
        }

        .upload-button {
            background: white;
            color: #667eea;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            font-weight: 600;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }

        .upload-button:hover {
            background: #f0f0f0;
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }

        .upload-button:active {
            transform: scale(0.98);
        }

        input[type="file"] {
            display: none;
        }

        .status-message {
            color: white;
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            font-size: 1em;
        }

        .status-message.error {
            background: rgba(255, 0, 0, 0.3);
        }

        .status-message.success {
            background: rgba(0, 255, 0, 0.3);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .locations-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è Local Guide</h1>
        
        <div class="locations-grid" id="locationsGrid">
            <div class="location-card empty">
                <div>Upload a CSV to find nearby locations</div>
            </div>
            <div class="location-card empty">
                <div>Upload a CSV to find nearby locations</div>
            </div>
            <div class="location-card empty">
                <div>Upload a CSV to find nearby locations</div>
            </div>
            <div class="location-card empty">
                <div>Upload a CSV to find nearby locations</div>
            </div>
        </div>

        <div class="upload-section">
            <label for="csvFile" class="upload-button">
                üìÅ Upload CSV File
            </label>
            <input type="file" id="csvFile" accept=".csv" />
        </div>

        <div id="statusMessage" class="status-message" style="display: none;"></div>
    </div>

    <script>
        let userLocation = null;
        let locations = [];
        let geocodeCache = {};

        // Load geocode cache from localStorage
        function loadCache() {
            try {
                const cached = localStorage.getItem('geocodeCache');
                if (cached) {
                    geocodeCache = JSON.parse(cached);
                }
            } catch (error) {
                console.error('Failed to load cache:', error);
            }
        }

        // Save geocode cache to localStorage
        function saveCache() {
            try {
                localStorage.setItem('geocodeCache', JSON.stringify(geocodeCache));
            } catch (error) {
                console.error('Failed to save cache:', error);
            }
        }

        // Get user's current location
        function getUserLocation() {
            return new Promise((resolve, reject) => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        position => resolve({
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        }),
                        error => reject(error)
                    );
                } else {
                    reject(new Error('Geolocation not supported'));
                }
            });
        }

        // Extract coordinates from Google Maps URL
        function extractCoordinatesSync(url) {
            // Handle various Google Maps URL formats
            // Format 1: maps.google.com/?q=lat,lng
            let match = url.match(/[?&]q=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
            if (match) {
                return { lat: parseFloat(match[1]), lng: parseFloat(match[2]) };
            }

            // Format 2: @lat,lng
            match = url.match(/@(-?\d+\.?\d*),(-?\d+\.?\d*)/);
            if (match) {
                return { lat: parseFloat(match[1]), lng: parseFloat(match[2]) };
            }

            // Format 3: /place/.../@lat,lng
            match = url.match(/place\/[^/]+\/@(-?\d+\.?\d*),(-?\d+\.?\d*)/);
            if (match) {
                return { lat: parseFloat(match[1]), lng: parseFloat(match[2]) };
            }

            // Format 4: ll=lat,lng
            match = url.match(/[?&]ll=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
            if (match) {
                return { lat: parseFloat(match[1]), lng: parseFloat(match[2]) };
            }

            return null;
        }

        // Geocode a place name with caching and parallel support
        async function geocodePlaceName(placeName) {
            // Check cache first
            if (geocodeCache[placeName]) {
                return geocodeCache[placeName];
            }

            try {
                // Use Photon geocoding API (based on OpenStreetMap data)
                const response = await fetch(
                    `https://photon.komoot.io/api/?q=${encodeURIComponent(placeName)}&limit=1`,
                    { method: 'GET' }
                );
                
                if (!response.ok) {
                    throw new Error('Geocoding service error');
                }
                
                const data = await response.json();
                if (data && data.features && data.features.length > 0) {
                    const coords = data.features[0].geometry.coordinates;
                    const result = {
                        lat: coords[1],  // GeoJSON uses [lng, lat] order
                        lng: coords[0]
                    };
                    
                    // Cache the result
                    geocodeCache[placeName] = result;
                    saveCache();
                    
                    return result;
                }
            } catch (error) {
                console.error('Geocoding error for', placeName, ':', error);
                
                // Fallback: try Nominatim
                try {
                    const response = await fetch(
                        `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(placeName)}&format=json&limit=1`,
                        { 
                            method: 'GET',
                            headers: {
                                'User-Agent': 'LocalGuide/1.0'
                            }
                        }
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data && data.length > 0) {
                            const result = {
                                lat: parseFloat(data[0].lat),
                                lng: parseFloat(data[0].lon)
                            };
                            
                            // Cache the result
                            geocodeCache[placeName] = result;
                            saveCache();
                            
                            return result;
                        }
                    }
                } catch (fallbackError) {
                    console.error('Fallback geocoding also failed:', fallbackError);
                }
            }
            return null;
        }

        // Calculate distance between two points using Haversine formula
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of Earth in kilometers
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Calculate bearing (direction) between two points
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
            const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
                      Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon);
            const bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }

        // Convert bearing to compass direction
        function bearingToDirection(bearing) {
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 
                              'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round(bearing / 22.5) % 16;
            return directions[index];
        }

        // Format distance for display
        function formatDistance(km) {
            if (km < 1) {
                return `${Math.round(km * 1000)} m`;
            } else if (km < 10) {
                return `${km.toFixed(1)} km`;
            } else {
                return `${Math.round(km)} km`;
            }
        }

        // Parse CSV file
        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const result = [];
            
            // Parse header to find column indices
            const header = lines[0].split(',').map(h => h.trim().toLowerCase());
            const titleIdx = header.indexOf('title');
            const noteIdx = header.indexOf('note');
            const urlIdx = header.indexOf('url');
            const nameIdx = header.indexOf('name');
            
            for (let i = 1; i < lines.length; i++) { // Skip header
                const line = lines[i].trim();
                if (!line || line === ',' || line === ',,,,' || line === ',,,,') continue;
                
                // Split CSV line respecting commas within quotes
                const columns = [];
                let currentCol = '';
                let inQuotes = false;
                
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        columns.push(currentCol.trim());
                        currentCol = '';
                    } else {
                        currentCol += char;
                    }
                }
                columns.push(currentCol.trim());
                
                // Get name from appropriate column (Title, Note, or Name)
                let name = '';
                if (titleIdx >= 0 && columns[titleIdx]) {
                    name = columns[titleIdx];
                }
                if (!name && noteIdx >= 0 && columns[noteIdx]) {
                    name = columns[noteIdx];
                }
                if (!name && nameIdx >= 0 && columns[nameIdx]) {
                    name = columns[nameIdx];
                }
                
                // Get URL
                let url = urlIdx >= 0 ? columns[urlIdx] : '';
                
                if (name && url) {
                    result.push({ name, url, coords: null });
                }
            }
            
            return result;
        }

        // Show status message
        function showStatus(message, type = 'info', autoHide = true) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = message;
            statusDiv.className = `status-message ${type}`;
            statusDiv.style.display = 'block';
            
            if (autoHide && type !== 'info') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Update the display with closest locations
        function updateDisplay(closestLocations) {
            const grid = document.getElementById('locationsGrid');
            
            for (let i = 0; i < 4; i++) {
                const card = grid.children[i];
                
                if (i < closestLocations.length) {
                    const loc = closestLocations[i];
                    card.className = 'location-card';
                    card.innerHTML = `
                        <div class="location-name">${loc.name}</div>
                        <div class="location-distance">${formatDistance(loc.distance)}</div>
                        <div class="location-direction">
                            <div class="compass">
                                <div class="compass-arrow" style="transform: rotate(${loc.bearing}deg)"></div>
                            </div>
                            <span>üìç ${loc.direction}</span>
                        </div>
                    `;
                    card.onclick = () => {
                        const directionsUrl = `https://www.google.com/maps/dir/?api=1&destination=${loc.coords.lat},${loc.coords.lng}`;
                        window.open(directionsUrl, '_blank');
                    };
                } else {
                    card.className = 'location-card empty';
                    card.innerHTML = '<div>No more locations</div>';
                    card.onclick = null;
                }
            }
        }

        // Process the uploaded CSV
        async function processCSV(text) {
            try {
                showStatus('Getting your location...', 'info');
                userLocation = await getUserLocation();
                
                showStatus('Parsing CSV file...', 'info');
                locations = parseCSV(text);
                
                if (locations.length === 0) {
                    showStatus('No valid locations found in CSV', 'error', true);
                    return;
                }

                showStatus(`Found ${locations.length} locations. Processing coordinates...`, 'info');

                // First pass: extract direct coordinates
                let geocodedCount = 0;
                let needsGeocode = [];
                
                for (let i = 0; i < locations.length; i++) {
                    const loc = locations[i];
                    
                    // Try to extract from URL directly
                    loc.coords = extractCoordinatesSync(loc.url);
                    
                    if (loc.coords) {
                        geocodedCount++;
                    } else {
                        // Extract place name for later geocoding
                        const placeMatch = loc.url.match(/place\/([^/]+)/);
                        if (placeMatch) {
                            const placeName = decodeURIComponent(placeMatch[1].replace(/\+/g, ' '));
                            loc.placeName = placeName;
                            
                            // Check cache
                            if (geocodeCache[placeName]) {
                                loc.coords = geocodeCache[placeName];
                                geocodedCount++;
                            } else {
                                needsGeocode.push(loc);
                            }
                        }
                    }
                }

                showStatus(`${geocodedCount} locations have coordinates. Geocoding ${needsGeocode.length} remaining...`, 'info');

                // Second pass: geocode in parallel batches
                if (needsGeocode.length > 0) {
                    const batchSize = 30; // Process 30 at a time for optimal speed
                    const delayBetweenBatches = 2000; // 2 seconds between batches
                    
                    for (let i = 0; i < needsGeocode.length; i += batchSize) {
                        const batch = needsGeocode.slice(i, i + batchSize);
                        
                        // Process batch in parallel
                        const results = await Promise.all(
                            batch.map(loc => geocodePlaceName(loc.placeName))
                        );
                        
                        // Assign results
                        batch.forEach((loc, idx) => {
                            if (results[idx]) {
                                loc.coords = results[idx];
                                geocodedCount++;
                            }
                        });
                        
                        showStatus(`Geocoding... ${Math.min(i + batchSize, needsGeocode.length)}/${needsGeocode.length} (${geocodedCount} total successful)`, 'info');
                        
                        // Delay between batches to respect rate limits
                        if (i + batchSize < needsGeocode.length) {
                            await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
                        }
                    }
                }

                // Filter out locations without coordinates
                const validLocations = locations.filter(loc => loc.coords);

                if (validLocations.length === 0) {
                    showStatus('Could not find coordinates for any locations', 'error', true);
                    return;
                }

                showStatus(`Calculating distances for ${validLocations.length} locations...`, 'info');

                // Calculate distances and bearings
                validLocations.forEach(loc => {
                    loc.distance = calculateDistance(
                        userLocation.lat, userLocation.lng,
                        loc.coords.lat, loc.coords.lng
                    );
                    loc.bearing = calculateBearing(
                        userLocation.lat, userLocation.lng,
                        loc.coords.lat, loc.coords.lng
                    );
                    loc.direction = bearingToDirection(loc.bearing);
                });

                // Sort by distance
                validLocations.sort((a, b) => a.distance - b.distance);

                // Get closest 4
                const closest = validLocations.slice(0, 4);
                
                updateDisplay(closest);
                showStatus(`Found ${validLocations.length} locations, showing closest 4`, 'success', true);
                
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error', true);
                console.error(error);
            }
        }

        // Handle file upload
        document.getElementById('csvFile').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    processCSV(e.target.result);
                };
                reader.readAsText(file);
            }
        });

        // Request location permission on load
        window.addEventListener('load', () => {
            loadCache(); // Load cached geocoding results
            showStatus('Click "Upload CSV File" to get started', 'info');
        });
    </script>
</body>
</html>
